/*
 *  _____ _
 * |_   _| |_  _ _ ___ ___ _ __  __ _
 *   | | | ' \| '_/ -_) -_) '  \/ _` |_
 *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
 *
 * Threema Gateway Java SDK
 * This SDK allows for preparing, sending and receiving of Threema Messages via Threema Gateway.
 *
 * The MIT License (MIT)
 * Copyright (c) 2015-2024 Threema GmbH
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE
 *
 *
 *
 *
 */
/*
 * NOTE: This class is auto generated by MsgApi SDK Generator (https://gateway.threema.ch/en/developer).
 * https://gateway.threema.ch/en/developer
 * Any changes made to this file will be overwritten upon re-generating.
*/

package ch.threema.apitool;

import ch.threema.apitool.exceptions.BadMessageException;
import ch.threema.apitool.exceptions.DecryptionFailedException;
import ch.threema.apitool.exceptions.MessageParseException;
import ch.threema.apitool.exceptions.UnsupportedMessageTypeException;
import ch.threema.apitool.messages.*;
import ch.threema.apitool.types.*;
import ch.threema.apitool.types.voting.*;
import ch.threema.apitool.results.EncryptResult;
import ch.threema.apitool.results.UploadResult;
import com.neilalexander.jnacl.NaCl;
import org.apache.commons.io.EndianUtils;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import static ch.threema.apitool.utils.ProtocolConstants.MIN_MESSAGE_PADDED_LEN;

/**
 * Contains static methods to do various Threema cryptography related tasks.
 */
public class CryptTool {

	/* HMAC-SHA256 keys for email/mobile phone hashing */
	private static final byte[] EMAIL_HMAC_KEY = new byte[] {(byte) 0x30, (byte) 0xa5, (byte) 0x50,
			(byte) 0x0f, (byte) 0xed, (byte) 0x97, (byte) 0x01, (byte) 0xfa, (byte) 0x6d,
			(byte) 0xef, (byte) 0xdb, (byte) 0x61, (byte) 0x08, (byte) 0x41, (byte) 0x90,
			(byte) 0x0f, (byte) 0xeb, (byte) 0xb8, (byte) 0xe4, (byte) 0x30, (byte) 0x88,
			(byte) 0x1f, (byte) 0x7a, (byte) 0xd8, (byte) 0x16, (byte) 0x82, (byte) 0x62,
			(byte) 0x64, (byte) 0xec, (byte) 0x09, (byte) 0xba, (byte) 0xd7};
	private static final byte[] PHONENO_HMAC_KEY = new byte[] {(byte) 0x85, (byte) 0xad,
			(byte) 0xf8, (byte) 0x22, (byte) 0x69, (byte) 0x53, (byte) 0xf3, (byte) 0xd9,
			(byte) 0x6c, (byte) 0xfd, (byte) 0x5d, (byte) 0x09, (byte) 0xbf, (byte) 0x29,
			(byte) 0x55, (byte) 0x5e, (byte) 0xb9, (byte) 0x55, (byte) 0xfc, (byte) 0xd8,
			(byte) 0xaa, (byte) 0x5e, (byte) 0xc4, (byte) 0xf9, (byte) 0xfc, (byte) 0xd8,
			(byte) 0x69, (byte) 0xe2, (byte) 0x58, (byte) 0x37, (byte) 0x07, (byte) 0x23};

	private static final byte[] FILE_NONCE = new byte[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x01};
	private static final byte[] FILE_THUMBNAIL_NONCE = new byte[] {0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x02};

	private static final SecureRandom random = new SecureRandom();

	/**
	 * Encrypt a Text
	 *
	 * @param text The message text
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Text encryption
	 **/
	public static EncryptResult encryptTextMessage(String text, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(new TextMessage(text), senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Location
	 *
	 * @param latitude The geographic latitude
	 * @param longitude The geographic longitude
	 * @param accuracy The location accuracy
	 * @param poiName The location name
	 * @param address The location address
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Location encryption
	 **/
	public static EncryptResult encryptLocationMessage(String latitude, String longitude,
					Float accuracy, String poiName, String address, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(new LocationMessage(latitude, longitude, accuracy, poiName, address),
						senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a File
	 *
	 * @param blobId The blob ID
	 * @param thumbnailBlobId The thumbnail blob ID
	 * @param thumbnailMediaType The thumbnail media type
	 * @param encryptionKey The encryption key
	 * @param mimeType The mime type
	 * @param fileName The filename
	 * @param size The file size
	 * @param caption The file caption
	 * @param renderingType The rendering type
	 * @param correlationId The correlation identifier
	 * @param metadata The metadata
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the File encryption
	 **/
	public static EncryptResult encryptFileMessage(byte[] blobId, byte[] thumbnailBlobId,
					String thumbnailMediaType, byte[] encryptionKey, String mimeType,
					String fileName, int size, String caption, FileRenderingType renderingType,
					String correlationId, Map<String, Object> metadata, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(
						new FileMessage(blobId, thumbnailBlobId, thumbnailMediaType, encryptionKey,
										mimeType, fileName, size, caption, renderingType,
										correlationId, metadata),
						senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Ballot
	 *
	 * @param ballotId The poll ballot identifier
	 * @param description The group poll description
	 * @param state The group poll state
	 * @param votingMode The voting mode
	 * @param resultsDisclosureType The poll results disclosure type
	 * @param order The poll results order (deprecated)
	 * @param displayMode The display mode
	 * @param choices The available vote choices
	 * @param participants The poll participants
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Ballot encryption
	 **/
	public static EncryptResult encryptBallotCreateMessage(byte[] ballotId, String description,
					State state, VotingMode votingMode, ResultsDisclosureType resultsDisclosureType,
					int order, DisplayMode displayMode, List<BallotChoice> choices,
					List<String> participants, byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new BallotCreateMessage(ballotId, description, state, votingMode,
						resultsDisclosureType, order, displayMode, choices, participants),
						senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Ballot
	 *
	 * @param creator The group poll creator
	 * @param ballotId The poll ballot identifier
	 * @param votes The votes tuple
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Ballot encryption
	 **/
	public static EncryptResult encryptBallotVoteMessage(byte[] creator, byte[] ballotId,
					List<VoteChoice> votes, byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new BallotVoteMessage(creator, ballotId, votes), senderPrivateKey,
						recipientPublicKey);
	}

	/**
	 * Encrypt a Delivery
	 *
	 * @param receiptType The message receipt type
	 * @param ackedMessageIds The acked message ids
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Delivery encryption
	 **/
	public static EncryptResult encryptDeliveryReceipt(DeliveryReceipt.Type receiptType,
					List<MessageId> ackedMessageIds, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(new DeliveryReceipt(receiptType, ackedMessageIds), senderPrivateKey,
						recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param receiptType The message receipt type
	 * @param ackedMessageIds The acked message ids
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupDeliveryReceipt(GroupId groupId,
					DeliveryReceipt.Type receiptType, List<MessageId> ackedMessageIds,
					byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new GroupDeliveryReceipt(groupId, receiptType, ackedMessageIds),
						senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param members The group members
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupCreateMessage(GroupId groupId, List<String> members,
					byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new GroupCreateMessage(groupId, members), senderPrivateKey,
						recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param groupName The group name
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupRenameMessage(GroupId groupId, String groupName,
					byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new GroupRenameMessage(groupId, groupName), senderPrivateKey,
						recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupLeaveMessage(GroupId groupId, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(new GroupLeaveMessage(groupId), senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param blobId The blob ID
	 * @param size The file size
	 * @param encryptionKey The encryption key
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupSetPhoto(GroupId groupId, byte[] blobId, int size,
					byte[] encryptionKey, byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new GroupSetPhoto(groupId, blobId, size, encryptionKey),
						senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupDeletePhoto(GroupId groupId, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(new GroupDeletePhoto(groupId), senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupRequestSyncMessage(GroupId groupId,
					byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new GroupRequestSyncMessage(groupId), senderPrivateKey,
						recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param text The message text
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupTextMessage(GroupId groupId, String text,
					byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new GroupTextMessage(groupId, text), senderPrivateKey,
						recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param latitude The geographic latitude
	 * @param longitude The geographic longitude
	 * @param accuracy The location accuracy
	 * @param poiName The location name
	 * @param address The location address
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupLocationMessage(GroupId groupId, String latitude,
					String longitude, Float accuracy, String poiName, String address,
					byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(new GroupLocationMessage(groupId, latitude, longitude, accuracy,
						poiName, address), senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param blobId The blob ID
	 * @param thumbnailBlobId The thumbnail blob ID
	 * @param thumbnailMediaType The thumbnail media type
	 * @param encryptionKey The encryption key
	 * @param mimeType The mime type
	 * @param fileName The filename
	 * @param size The file size
	 * @param caption The file caption
	 * @param renderingType The rendering type
	 * @param correlationId The correlation identifier
	 * @param metadata The metadata
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupFileMessage(GroupId groupId, byte[] blobId,
					byte[] thumbnailBlobId, String thumbnailMediaType, byte[] encryptionKey,
					String mimeType, String fileName, int size, String caption,
					FileRenderingType renderingType, String correlationId,
					Map<String, Object> metadata, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(
						new GroupFileMessage(groupId, blobId, thumbnailBlobId, thumbnailMediaType,
										encryptionKey, mimeType, fileName, size, caption,
										renderingType, correlationId, metadata),
						senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param ballotId The poll ballot identifier
	 * @param description The group poll description
	 * @param state The group poll state
	 * @param votingMode The voting mode
	 * @param resultsDisclosureType The poll results disclosure type
	 * @param order The poll results order (deprecated)
	 * @param displayMode The display mode
	 * @param choices The available vote choices
	 * @param participants The poll participants
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupBallotCreateMessage(GroupId groupId, byte[] ballotId,
					String description, State state, VotingMode votingMode,
					ResultsDisclosureType resultsDisclosureType, int order, DisplayMode displayMode,
					List<BallotChoice> choices, List<String> participants, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(
						new GroupBallotCreateMessage(groupId, ballotId, description, state,
										votingMode, resultsDisclosureType, order, displayMode,
										choices, participants),
						senderPrivateKey, recipientPublicKey);
	}

	/**
	 * Encrypt a Group
	 *
	 * @param groupId The group identifier
	 * @param creator The group poll creator
	 * @param ballotId The poll ballot identifier
	 * @param votes The votes array
	 * @param senderPrivateKey Private key of sender
	 * @param recipientPublicKey Public key of recipient
	 * @return Result of the Group encryption
	 **/
	public static EncryptResult encryptGroupBallotVoteMessage(GroupId groupId, byte[] creator,
					byte[] ballotId, List<VoteChoice> votes, byte[] senderPrivateKey,
					byte[] recipientPublicKey) {
		return encryptMessage(new GroupBallotVoteMessage(groupId, creator, ballotId, votes),
						senderPrivateKey, recipientPublicKey);
	}


	/**
	 * Encrypt an image message.
	 *
	 * @param encryptResult result of the image encryption
	 * @param uploadResult result of the upload
	 * @param senderPrivateKey the private key of the sending ID
	 * @param recipientPublicKey the public key of the receiving ID
	 * @return encrypted result
	 * @deprecated
	 */
	@Deprecated
	public static EncryptResult encryptImageMessage(EncryptResult encryptResult,
					UploadResult uploadResult, byte[] senderPrivateKey, byte[] recipientPublicKey) {
		return encryptMessage(
						new ImageMessage(uploadResult.getBlobId(), encryptResult.getSize(),
										encryptResult.getNonce()),
						senderPrivateKey, recipientPublicKey);
	}

	private static EncryptResult encryptMessage(ThreemaMessage threemaMessage, byte[] privateKey,
					byte[] publicKey) {
		/* determine random amount of PKCS7 padding */
		int padbytes = random.nextInt(254) + 1;

		byte[] messageBytes;
		try {
			messageBytes = threemaMessage.getData();
		} catch (BadMessageException e) {
			return null;
		}

		byte[] data;
		if (1 + messageBytes.length + padbytes < MIN_MESSAGE_PADDED_LEN) {
			/* Ensure the message data incl. padding amounts to at least MIN_MESSAGE_PADDED_LEN bytes for security reasons */
			padbytes = MIN_MESSAGE_PADDED_LEN - (1 + messageBytes.length);
		}

		/* prepend type byte (0x02) to message data */
		data = new byte[1 + messageBytes.length + padbytes];
		data[0] = (byte) threemaMessage.getTypeCode();

		System.arraycopy(messageBytes, 0, data, 1, messageBytes.length);

		/* append padding */
		for (int i = 0; i < padbytes; i++) {
			data[i + 1 + messageBytes.length] = (byte) padbytes;
		}

		return encrypt(data, privateKey, publicKey);
	}

	private static EncryptResult encryptMessage(ThreemaGroupMessage groupMessage, byte[] privateKey,
					byte[] publicKey) {
		/* determine random amount of PKCS7 padding */
		int padbytes = random.nextInt(254) + 1;

		byte[] messageBytes;
		try {
			messageBytes = groupMessage.getData();
		} catch (BadMessageException e) {
			return null;
		}

		boolean needsCreatorIdentity = true;
		try {
			needsCreatorIdentity = !groupMessage.getClass().getField("noPrependGroupCreator")
							.getBoolean(groupMessage);
		} catch (IllegalAccessException | NoSuchFieldException ignored) {
		}

		byte[] groupIdentifier = new byte[GroupId.GROUP_ID_LEN
						+ (needsCreatorIdentity ? GroupId.CREATOR_ID_LEN : 0)];
		if (needsCreatorIdentity) {
			System.arraycopy(groupMessage.getGroupId().getGroupCreator(), 0, groupIdentifier, 0,
							GroupId.CREATOR_ID_LEN);
			System.arraycopy(groupMessage.getGroupId().getGroupId(), 0, groupIdentifier,
							GroupId.CREATOR_ID_LEN, GroupId.GROUP_ID_LEN);
		} else {
			System.arraycopy(groupMessage.getGroupId().getGroupId(), 0, groupIdentifier, 0,
							GroupId.GROUP_ID_LEN); // groupMessage.getGroupId().getGroupCreator().concat(groupMessage.getGroupId().getGroupId()).getBytes(StandardCharsets.UTF_8);
		}

		/* prepend type byte (0x02) to message data */
		byte[] data;
		if (1 + groupIdentifier.length + messageBytes.length + padbytes < MIN_MESSAGE_PADDED_LEN) {
			/* Ensure the message data incl. padding amounts to at least MIN_MESSAGE_PADDED_LEN bytes for security reasons */
			padbytes = MIN_MESSAGE_PADDED_LEN - (1 + groupIdentifier.length + messageBytes.length);
		}

		/* prepend type byte (0x02) to message data */
		data = new byte[1 + groupIdentifier.length + messageBytes.length + padbytes];
		data[0] = (byte) groupMessage.getTypeCode();

		System.arraycopy(groupIdentifier, 0, data, 1, groupIdentifier.length);
		System.arraycopy(messageBytes, 0, data, 1 + groupIdentifier.length, messageBytes.length);

		/* append padding */
		for (int i = 0; i < padbytes; i++) {
			data[i + 1 + groupIdentifier.length + messageBytes.length] = (byte) padbytes;
		}

		return encrypt(data, privateKey, publicKey);
	}

	/**
	 * Decrypt an NaCl box using the recipient's private key and the sender's public key.
	 *
	 * @param box The box to be decrypted
	 * @param privateKey The private key of the recipient
	 * @param publicKey The public key of the sender
	 * @param nonce The nonce that was used for encryption
	 * @return The decrypted data, or null if decryption failed
	 */
	public static byte[] decrypt(byte[] box, byte[] privateKey, byte[] publicKey, byte[] nonce) {
		return new NaCl(privateKey, publicKey).decrypt(box, nonce);
	}

	/**
	 * Decrypt symmetrically encrypted file data.
	 *
	 * @param fileData The encrypted file data
	 * @param secret The symmetric key that was used for encryption
	 * @return The decrypted file data, or null if decryption failed
	 */
	public static byte[] decryptFileData(byte[] fileData, byte[] secret) {
		return NaCl.symmetricDecryptData(fileData, secret, FILE_NONCE);
	}

	/**
	 * Decrypt symmetrically encrypted file thumbnail data.
	 *
	 * @param fileData The encrypted thumbnail data
	 * @param secret The symmetric key that was used for encryption
	 * @return The decrypted thumbnail data, or null if decryption failed
	 */
	public static byte[] decryptFileThumbnailData(byte[] fileData, byte[] secret) {
		return NaCl.symmetricDecryptData(fileData, secret, FILE_THUMBNAIL_NONCE);
	}

	/**
	 * Decrypt a message.
	 *
	 * @param box the box to be decrypted
	 * @param recipientPrivateKey the private key of the receiving ID
	 * @param senderPublicKey the public key of the sending ID
	 * @param nonce the nonce that was used for the encryption
	 * @return decrypted message (text or delivery receipt)
	 */
	public static ThreemaMessage decryptMessage(byte[] box, byte[] recipientPrivateKey,
					byte[] senderPublicKey, byte[] nonce) throws MessageParseException {

		byte[] data = decrypt(box, recipientPrivateKey, senderPublicKey, nonce);
		if (data == null)
			throw new DecryptionFailedException();

		/* remove padding */
		int padbytes = data[data.length - 1] & 0xFF;
		int realDataLength = data.length - padbytes;
		if (realDataLength < 1)
			throw new BadMessageException(); /* Bad message padding */

		/* first byte of data is type */
		int type = data[0] & 0xFF;

		switch (type) {
			case TextMessage.TYPE_CODE:
				return TextMessage.fromString(data, realDataLength);

			case LocationMessage.TYPE_CODE:
				return LocationMessage.fromString(data, realDataLength);

			case FileMessage.TYPE_CODE:
				return FileMessage.fromString(data, realDataLength);

			case BallotCreateMessage.TYPE_CODE:
				return BallotCreateMessage.fromString(data, realDataLength);

			case BallotVoteMessage.TYPE_CODE:
				return BallotVoteMessage.fromString(data, realDataLength);

			case DeliveryReceipt.TYPE_CODE:
				return DeliveryReceipt.fromString(data, realDataLength);

			case GroupCreateMessage.TYPE_CODE:
				return GroupCreateMessage.fromString(data, realDataLength);

			case GroupRenameMessage.TYPE_CODE:
				return GroupRenameMessage.fromString(data, realDataLength);

			case GroupLeaveMessage.TYPE_CODE:
				return GroupLeaveMessage.fromString(data, realDataLength);

			case GroupSetPhoto.TYPE_CODE:
				return GroupSetPhoto.fromString(data, realDataLength);

			case GroupDeletePhoto.TYPE_CODE:
				return GroupDeletePhoto.fromString(data, realDataLength);

			case GroupDeliveryReceipt.TYPE_CODE:
				return GroupDeliveryReceipt.fromString(data, realDataLength);

			case GroupRequestSyncMessage.TYPE_CODE:
				return GroupRequestSyncMessage.fromString(data, realDataLength);

			case GroupTextMessage.TYPE_CODE:
				return GroupTextMessage.fromString(data, realDataLength);

			case GroupLocationMessage.TYPE_CODE:
				return GroupLocationMessage.fromString(data, realDataLength);

			case GroupFileMessage.TYPE_CODE:
				return GroupFileMessage.fromString(data, realDataLength);

			case GroupBallotCreateMessage.TYPE_CODE:
				return GroupBallotCreateMessage.fromString(data, realDataLength);

			case GroupBallotVoteMessage.TYPE_CODE:
				return GroupBallotVoteMessage.fromString(data, realDataLength);


			case ImageMessage.TYPE_CODE:
				if (realDataLength != (1 + ThreemaMessage.BLOB_ID_LEN + 4 + NaCl.NONCEBYTES)) {
					System.out.println(realDataLength);
					System.out.println(1 + ThreemaMessage.BLOB_ID_LEN + 4 + NaCl.NONCEBYTES);
					throw new BadMessageException();
				}
				byte[] blobId = new byte[ThreemaMessage.BLOB_ID_LEN];
				System.arraycopy(data, 1, blobId, 0, ThreemaMessage.BLOB_ID_LEN);
				int size = EndianUtils.readSwappedInteger(data, 1 + ThreemaMessage.BLOB_ID_LEN);
				byte[] fileNonce = new byte[NaCl.NONCEBYTES];
				System.arraycopy(data, 1 + 4 + ThreemaMessage.BLOB_ID_LEN, fileNonce, 0,
								nonce.length);

				return new ImageMessage(blobId, size, fileNonce);

			default:
				throw new UnsupportedMessageTypeException();
		}
	}

	/**
	 * Generate a new key pair.
	 *
	 * @param privateKey is used to return the generated private key (length must be
	 *        NaCl.PRIVATEKEYBYTES)
	 * @param publicKey is used to return the generated public key (length must be
	 *        NaCl.PUBLICKEYBYTES)
	 */
	public static void generateKeyPair(byte[] privateKey, byte[] publicKey) {
		if (publicKey.length != NaCl.PUBLICKEYBYTES || privateKey.length != NaCl.SECRETKEYBYTES) {
			throw new IllegalArgumentException("Wrong key length");
		}

		NaCl.genkeypair(publicKey, privateKey);
	}

	/**
	 * Encrypt data using NaCl asymmetric ("box") encryption.
	 *
	 * @param data the data to be encrypted
	 * @param privateKey is used to return the generated private key (length must be
	 *        NaCl.PRIVATEKEYBYTES)
	 * @param publicKey is used to return the generated public key (length must be
	 *        NaCl.PUBLICKEYBYTES)
	 */
	public static EncryptResult encrypt(byte[] data, byte[] privateKey, byte[] publicKey) {
		if (publicKey.length != NaCl.PUBLICKEYBYTES || privateKey.length != NaCl.SECRETKEYBYTES) {
			throw new IllegalArgumentException("Wrong key length");
		}

		byte[] nonce = randomNonce();
		NaCl naCl = new NaCl(privateKey, publicKey);
		return new EncryptResult(naCl.encrypt(data, nonce), null, nonce);
	}

	/**
	 * Encrypt file data using NaCl symmetric encryption with a random key.
	 *
	 * @param data the file contents to be encrypted
	 * @return the encryption result including the random key
	 */
	public static EncryptResult encryptFileData(byte[] data) {
		// create random key
		SecureRandom rnd = new SecureRandom();
		byte[] encryptionKey = new byte[NaCl.SYMMKEYBYTES];
		rnd.nextBytes(encryptionKey);

		// encrypt file data in-place
		NaCl.symmetricEncryptDataInplace(data, encryptionKey, FILE_NONCE);

		return new EncryptResult(data, encryptionKey, FILE_NONCE);
	}

	/**
	 * Encrypt file thumbnail data using NaCl symmetric encryption with a random key.
	 *
	 * @param data the file contents to be encrypted
	 * @return the encryption result including the random key
	 */
	public static EncryptResult encryptFileThumbnailData(byte[] data, byte[] encryptionKey) {
		// encrypt file data in-place
		NaCl.symmetricEncryptDataInplace(data, encryptionKey, FILE_THUMBNAIL_NONCE);

		return new EncryptResult(data, encryptionKey, FILE_THUMBNAIL_NONCE);
	}

	/**
	 * Hashes an email address for identity lookup.
	 *
	 * @param email the email address
	 * @return the raw hash
	 */
	public static byte[] hashEmail(String email) {
		try {
			Mac emailMac = Mac.getInstance("HmacSHA256");
			emailMac.init(new SecretKeySpec(EMAIL_HMAC_KEY, "HmacSHA256"));
			String normalizedEmail = email.toLowerCase().trim();
			return emailMac.doFinal(normalizedEmail.getBytes(StandardCharsets.US_ASCII));
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Hashes a phone number for identity lookup.
	 *
	 * @param phoneNo the phone number
	 * @return the raw hash
	 */
	public static byte[] hashPhoneNo(String phoneNo) {
		try {
			Mac phoneMac = Mac.getInstance("HmacSHA256");
			phoneMac.init(new SecretKeySpec(PHONENO_HMAC_KEY, "HmacSHA256"));
			String normalizedPhoneNo = phoneNo.replaceAll("[^0-9]", "");
			return phoneMac.doFinal(normalizedPhoneNo.getBytes(StandardCharsets.US_ASCII));
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Generate a random nonce.
	 *
	 * @return random nonce
	 */
	public static byte[] randomNonce() {
		byte[] nonce = new byte[NaCl.NONCEBYTES];
		random.nextBytes(nonce);
		return nonce;
	}

	/**
	 * Return the public key that corresponds with a given private key.
	 *
	 * @param privateKey The private key whose public key should be derived
	 * @return The corresponding public key.
	 */
	public static byte[] derivePublicKey(byte[] privateKey) {
		return NaCl.derivePublicKey(privateKey);
	}
}
